import { spawn, spawnSync } from 'node:child_process';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as crypto from 'node:crypto';
import { WorkerSpawner, SpawnResult, SpawnInfo } from './worker-spawner.js';
import { WorkerSpawnRequest } from '../session/types.js';

/**
 * Windows Terminal worker spawner.
 * Spawns Claude Code workers in new Windows Terminal tabs.
 */
export class WindowsTerminalSpawner implements WorkerSpawner {
  private wtPath: string | null = null;

  getName(): string {
    return 'Windows Terminal';
  }

  /**
   * Checks if Windows Terminal is available.
   * Uses fs.existsSync and 'where' command to avoid opening windows.
   */
  isAvailable(): boolean {
    if (this.wtPath !== null) {
      return true;
    }

    // Check if wt.exe exists in WindowsApps
    const windowsAppsPath = path.join(
      process.env.LOCALAPPDATA || '',
      'Microsoft',
      'WindowsApps',
      'wt.exe'
    );

    if (fs.existsSync(windowsAppsPath)) {
      this.wtPath = windowsAppsPath;
      return true;
    }

    // Check if wt.exe is in PATH using 'where' command (doesn't open windows)
    try {
      const result = spawnSync('where', ['wt.exe'], {
        stdio: 'pipe',
        windowsHide: true,
      });
      if (result.status === 0) {
        this.wtPath = 'wt.exe';
        return true;
      }
    } catch {
      // Ignore errors
    }

    return false;
  }

  /**
   * Spawns a Claude Code worker in a new Windows Terminal tab.
   */
  async spawn(request: WorkerSpawnRequest): Promise<SpawnResult> {
    const spawnId = crypto.randomUUID();
    const spawnedAt = new Date().toISOString();

    if (!this.isAvailable()) {
      return {
        success: false,
        spawnId,
        spawnedAt,
        error: 'Windows Terminal is not available',
      };
    }

    // Write spawn info to worktree for tracking
    const spawnInfo: SpawnInfo = {
      spawnId,
      spawnedAt,
      issueNumber: request.issueNumber,
    };
    await this.writeSpawnInfo(request.workingDirectory, spawnInfo);

    const tabTitle = `Issue #${request.issueNumber}`;

    // Build the Claude command
    const claudeCommand = this.buildClaudeCommand(request);

    // Write wrapper script and build command to execute it
    const wrapperScriptPath = await this.writeWrapperScript(request.workingDirectory, claudeCommand);
    const wrapperCommand = `powershell -NoProfile -ExecutionPolicy Bypass -File "${wrapperScriptPath}"`;

    // Windows Terminal command to open a new tab
    // Use cmd /c with wrapper - wrapper decides whether to close or stay open
    const args = [
      'new-tab',
      '--title', tabTitle,
      '--startingDirectory', request.workingDirectory,
      'cmd', '/c', wrapperCommand,
    ];

    return new Promise((resolve) => {
      const proc = spawn(this.wtPath || 'wt.exe', args, {
        detached: true,
        stdio: 'ignore',
      });

      proc.on('error', (error) => {
        resolve({
          success: false,
          spawnId,
          spawnedAt,
          error: `Failed to spawn Windows Terminal: ${error.message}`,
        });
      });

      // Don't wait for the process - it's detached
      proc.unref();

      // Give it a moment to start
      setTimeout(() => {
        resolve({
          success: true,
          spawnId,
          spawnedAt,
        });
      }, 500);
    });
  }

  /**
   * Writes spawn info to the worktree for tracking.
   */
  private async writeSpawnInfo(workingDirectory: string, info: SpawnInfo): Promise<void> {
    const claudeDir = path.join(workingDirectory, '.claude');
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
    }
    const infoPath = path.join(claudeDir, 'spawn-info.json');
    await fs.promises.writeFile(infoPath, JSON.stringify(info, null, 2), 'utf-8');
  }

  /**
   * Writes a PowerShell wrapper script that manages Claude's lifecycle.
   * - Uses a background job to monitor session status
   * - Runs Claude directly in foreground (blocking, output visible, interactive)
   * - When status becomes complete/cancelled, kills entire process tree with taskkill
   * - Exits with code 0 to allow Windows Terminal to close the tab
   */
  private async writeWrapperScript(worktreePath: string, claudeCommand: string): Promise<string> {
    const scriptPath = path.join(worktreePath, '.claude', 'worker-wrapper.ps1');

    const script = `# Worker Wrapper Script - Auto-generated by orchestrator
# Manages Claude lifecycle based on session status

$ErrorActionPreference = 'SilentlyContinue'

# Get session file path from context
$ctx = Get-Content 'session-context.json' -Raw | ConvertFrom-Json
$sessionPath = $ctx.sessionFilePath

if (-not $sessionPath) {
    Write-Host 'ERROR: No sessionFilePath in session-context.json'
    Read-Host 'Press Enter to exit'
    exit 1
}

# Get wrapper script's PID for the background job to kill
$wrapperPid = $PID

Write-Host "Worker started. Monitoring session: $sessionPath"

# Start background job to monitor session status
$watcherJob = Start-Job -ScriptBlock {
    param($sessionPath, $wrapperPid)

    while ($true) {
        Start-Sleep -Seconds 2

        try {
            $session = Get-Content $sessionPath -Raw -ErrorAction Stop | ConvertFrom-Json
            $status = $session.status

            if ($status -eq 'complete' -or $status -eq 'cancelled') {
                # Kill entire process tree including wrapper
                # Using Start-Process to run taskkill ensures it completes
                Start-Process -FilePath 'taskkill' -ArgumentList '/T', '/F', '/PID', $wrapperPid -NoNewWindow -Wait
                exit 0
            }
        } catch {
            # Ignore read errors, keep polling
        }
    }
} -ArgumentList $sessionPath, $wrapperPid

# Run Claude directly (blocking, output visible, interactive)
& cmd /c '${claudeCommand}'

# Claude exited - clean up watcher job
Remove-Job -Job $watcherJob -Force -ErrorAction SilentlyContinue

# Check final status
$session = $null
try {
    $session = Get-Content $sessionPath -Raw | ConvertFrom-Json
    if ($session.status -eq 'complete' -or $session.status -eq 'cancelled') {
        [Environment]::Exit(0)
    }
} catch {}

# Not complete - show status and wait for user
Write-Host ''
Write-Host '=================================================='
Write-Host '  Worker stopped. Status: ' -NoNewline
if ($session) { Write-Host $session.status -ForegroundColor Yellow } else { Write-Host 'unknown' -ForegroundColor Red }
if ($session -and $session.stuckReason) {
    Write-Host "  Reason: $($session.stuckReason)" -ForegroundColor Cyan
}
Write-Host '  Review the output above, then press any key...'
Write-Host '=================================================='
$null = $Host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown')
`;

    const claudeDir = path.dirname(scriptPath);
    if (!fs.existsSync(claudeDir)) {
      fs.mkdirSync(claudeDir, { recursive: true });
    }
    await fs.promises.writeFile(scriptPath, script, 'utf-8');
    return scriptPath;
  }

  /**
   * Builds the Claude command to run in the terminal.
   */
  private buildClaudeCommand(request: WorkerSpawnRequest): string {
    // Bootstrap instruction tells Claude where to find full instructions
    // The full prompt is already written to .claude/session-prompt.md by writeWorkerPrompt()
    const bootstrap =
      `You are an autonomous worker for Issue #${request.issueNumber}. ` +
      `Read .claude/session-prompt.md for your full instructions and begin.`;

    // Escape quotes for Windows cmd by doubling them
    const escaped = bootstrap.replace(/"/g, '""');

    // --dangerously-skip-permissions bypasses trust prompts for new worktree directories
    // This is safe because: issues come from user's own GitHub repo, worktrees are from
    // trusted branches, and prompts are generated by our code
    return `claude --dangerously-skip-permissions "${escaped}"`;
  }
}

/**
 * Creates the appropriate spawner for the current platform.
 */
export function createSpawner(): WorkerSpawner {
  if (process.platform === 'win32') {
    return new WindowsTerminalSpawner();
  }

  // TODO: Add support for other platforms (macOS with iTerm, Linux with tmux)
  throw new Error(`No worker spawner available for platform: ${process.platform}`);
}
